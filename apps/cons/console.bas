;BASIC MULTIUSE VARS
BYTE A = 0
BYTE B = 0
BYTE C = 0
BYTE D = 0
BYTE I = 0
BYTE E = 0
BYTE F = 0
BYTE G = 0
BYTE H = 0
BYTE J = 0
BYTE K = 0
BYTE L = 0

BYTE V = 0

SHORT O = 0
SHORT X = 0

;STORES IF CLI (COMMAND LINE INTERPRETER) IS ACTIVE
BYTE ISCLI = 0
BYTE NEWPID = 0
BYTE CLIPON = 0
BYTE CLIPRINT = 1
;BATCH FILE CONTROL
BYTE ISBAT = 0
;PCB CONTROL
BYTE ISPCB = 0
;HANDLES CLI BUFFER POINTER
BYTE CLIP = 0

;STRING STORAGE
STRING S[54] = "MICRON SYS/I",10,0,"PANIC ",0,"AUTOEXEC RTN",10,0,"ERROR ",0,"READY",10,".",0
STRING PRG[5] = ".PRG",0

;FILE COMMAND BUFFER
STRING AE[20] = ""
STRING BE[20] = 1,0,0,0,"START.BAT",0

;CLI BUFFER
MEM CLIBUF
MEM CLITEMP

;FSD MANAGMENT
STRING FSDPIP[16] = ""
STRING FSDNAM[16] = "SY??????????????"
BYTE MAXFSD = 8
BYTE FSDNUM = 0
SHORT CURFSD = 0
BYTE CURSUB = 0
SHORT TEMFSD = 0
BYTE TEMSUB = 0

;PROCESS COMMAND/IO BUFFERS
STRING PCBSTAT[16] = ""
BYTE MAXPRG = 16
MEM P0
MEM P1
MEM P2
MEM P3
MEM P4
MEM P5
MEM P6
MEM P7
MEM P8
MEM P9
MEM P10
MEM P11
MEM P12
MEM P13
MEM P14
MEM P15

;TEMP MEM SLOT
MEM T
MEM TT
MEM R
MEM RR
MEM BUF

@START
	LET FSDPIP[0] = #SYS[0]
	LET FSDPIP[1] = #SYS[1]
	LET FSDNUM = MAXFSD
	LET MAXFSD =+ MAXFSD
	LET O = #SIO
	LET X = #SIO
	LET CURFSD = #SYS
	LET I = 0
	GOSUB PRINTI
	
	;PREPARE MEM
	ALLOC CLIBUF,1,E
	GOSUB CHECKE

	;AUTOEXEC ROUTINE
	GOSUB BATEXE

	;PREPARE CLI
	GOSUB CLION

MAINLOOP:
	FORFIT
	IF ISCLI = 1 GOSUB HANCLI
	GOSUB CHECKPCB
	GOTO MAINLOOP
	
CHECKPCB:
	LET I = 0
CHECKPCB1:
	IF PCBSTAT[I] > 0 GOSUB EXEPCB
	INC I
	IF I < MAXPRG GOTO CHECKPCB1
	RETURN
	
EXEPCB:
	LET ISPCB = 1
	GOSUB GETPCB
	LET G = I
	LET K = I
	LET H = T[0]
	LET L = 0
	IF H = 255 GOSUB KILLPROC
	IF H = 254 GOSUB PCBCLI
	IF H = 34 GOSUB PCBRFS
	IF H = 33 GOSUB PCBPFS
	IF H = 32 GOSUB PCBLFS
	IF H = 16 GOSUB PCBEXE
	IF H = 12 GOSUB PCBSIZ
	IF H = 11 GOSUB DIR
	IF H = 10 GOSUB PCBFOR
	IF H = 9 GOSUB PCBUMN
	IF H = 8 GOSUB PCBMNT
	IF H = 7 GOSUB PCBSTT
	IF H = 4 GOSUB PCBDEL
	IF H = 3 GOSUB PCBCRT
	IF H = 2 GOSUB PCBWRT
	IF H = 1 GOSUB PCBSEC
	LET I = K
	GOSUB GETPCB
	LET ISPCB = 0
	RETURN
	
PCBRFS:
	GOSUB HASFSD
	IF B = 1 GOTO PCBRFS1
	LET T[126] = 22
	LET T[0] = 0
	RETURN
PCBRFS1:
	LET FSDNAM[A] = 63
	INC A
	LET FSDNAM[A] = 63
	LET T[126] = 0
	LET T[0] = 0
	RETURN
	
PCBPFS:
	GOSUB HASFSD
	IF B = 1 GOTO PCBPFS3
	LET A = 0
PCBPFS1:
	IF FSDNAM[A] = 63 GOTO PCBPFS2
	LET A =+ 2
	IF A < MAXFSD GOTO PCBPFS1
	LET T[126] = 23
	GOTO PCBPFS4
PCBPFS2:
	LET FSDNAM[A] = T[1]
	LET FSDPIP[A] = T[3]
	INC A
	LET FSDNAM[A] = T[2]
	LET FSDPIP[A] = T[4]
	LET T[126] = 0
	GOTO PCBPFS4
PCBPFS3:
	LET T[126] = 24
PCBPFS4:
	LET T[0] = 0
	RETURN
	
HASFSD:
	LET A = 0
	LET B = 0
HASFSD1:
	IF FSDNAM[A] = T[1] GOTO HASFSD2
	LET A =+ 2
	IF A < MAXFSD GOTO HASFSD1
	RETURN
HASFSD2:
	INC A
	IF FSDNAM[A] = T[2] GOTO HASFSD3
	INC A
	RETURN
HASFSD3:
	DEC A
	LET B = 1
	RETURN
	
PCBLFS:
	LET T[1] = FSDNUM
	LET A = MAXFSD
	LET I = 128
	LET L = 0
PCBLFS1:
	LET T[I] = FSDNAM[L]
	INC I
	INC L
	IF A > L GOTO PCBLFS1
	LET T[126] = 0
	LET T[0] = 0
	RETURN
	
	
	
PCBSIZ:
	LET AE[0] = 12
	LET L = 1
	GOTO PCBSCO
PCBFOR:
	LET AE[0] = 10
	GOTO PCBSCO
PCBUMN:
	LET AE[0] = 9
	GOTO PCBSCO
PCBMNT:
	LET AE[0] = 8
	GOTO PCBSCO
PCBSTT:
	LET AE[0] = 7
PCBSCO:
	GOSUB GETFSD
	IF C > 0 GOTO ERRORSWI
	LET AE[1] = T[3]
	LET O = CURFSD
	LET C = AE[0]
	GOSUB PUTC
	LET C = AE[1]
	GOSUB PUTC
	GOSUB PULLC
	LET T[0] = 0
	LET T[126] = C
	IF L = 1 GOSUB PUTSIZ
	GOSUB TEMTOCUR
	LET O = #SIO
	RETURN
	
PUTSIZ:
	LET I = 1
PUTSIZ1:
	GOSUB PULLC
	LET T[I] = C
	INC I
	IF I < 4 GOTO PUTSIZ1
	RETURN
	
PCBEXE:
	ALLOC CLITEMP,1,C
	IF C > 0 GOTO ERRORPCB
	LET I = 0
	LET A = 128
PCBEXE1:
	LET CLITEMP[I] = T[A]
	INC I
	INC A
	IF A > 0 GOTO PCBEXE1
	LET #SIO[0] = T[1]
	LET #SIO[1] = T[2]
	LET J = CLIP
	MOVE TT,T
	MOVE RR,CLIBUF
	MOVE CLIBUF,CLITEMP
	GOSUB CLILOAD
	DALLOC CLIBUF
	MOVE CLIBUF,RR
	MOVE T,TT
	LET T[126] = E
	LET T[1] = NEWPID
	LET CLIP = J
	LET #SIO = X
	LET H = 0
	LET O = #SIO
	LET T[0] = 0
	RETURN

DIR:
	GOSUB GETFSD
	IF C > 0 GOTO ERRORSWI
	LET O = CURFSD
	LET C = 11
	GOSUB PUTC
	LET C = T[3]
	GOSUB PUTC
	LET C = T[4]
	GOSUB PUTC
	GOSUB PULLC
	IF C > 0 GOTO ERRORSWI
	LET T[126] = 0
	LET I = 0
	LET A = 128
DIR1:
	GOSUB PULLC
	LET T[A] = C
	INC A
	INC I
	IF I < 16 GOTO DIR1
	LET O = #SIO
	GOSUB TEMTOCUR
	LET T[0] = 0
	RETURN
	
GETFSD:
	GOSUB CURTOTEM
	LET C = 0
	IF T[1] < 255 GOSUB SWIFSD
	GOTO SWISUB
	
PCBDEL:
	LET AE[0] = 4
	GOTO PCBCOM
PCBCRT:
	LET AE[0] = 3
PCBCOM:
	GOSUB GETFSD
	IF C > 0 GOTO ERRORSWI
	LET I = 3
	LET A = 1
PCBCOM1:
	LET AE[A] = T[I]
	INC I
	INC A
	IF I < 20 GOTO PCBCOM1
	GOSUB GETSEC
	IF C > 0 GOTO ERRORSWI
	LET T[0] = 0
	LET T[126] = 0
	GOSUB TEMTOCUR
	LET O = #SIO
	RETURN

PCBWRT:
	GOSUB GETFSD
	IF C > 0 GOTO ERRORSWI
	LET AE[0] = 2
	LET I = 3
	LET A = 1
PCBWRT1:
	LET AE[A] = T[I]
	INC I
	INC A
	IF I < 20 GOTO PCBWRT1
	GOSUB GETSEC
	IF C > 0 GOTO ERRORSWI
	LET I = 128
PCBWRT2:
	LET C = T[I]
	GOSUB PUTC
	INC I
	IF I > 0 GOTO PCBWRT2
	LET T[0] = 0
	LET T[126] = 0
	GOSUB TEMTOCUR
	LET O = #SIO
	RETURN

PCBSEC:
	GOSUB GETFSD
	IF C > 0 GOTO ERRORSWI
	LET AE[0] = 1
	LET I = 3
	LET A = 1
PCBSEC1:
	LET AE[A] = T[I]
	INC I
	INC A
	IF I < 20 GOTO PCBSEC1
	GOSUB GETSEC
	IF C > 0 GOTO ERRORSWI
	LET I = 128
PCBSEC2:
	GOSUB PULLC
	LET T[I] = C
	INC I
	IF I > 0 GOTO PCBSEC2
	LET T[126] = 0
	LET T[0] = 0
	GOSUB TEMTOCUR
	LET O = #SIO
	RETURN
	
SWIFSD:
	LET C = 0
	LET A = 0
SWIFSD1:
	IF A = MAXFSD GOTO SWIFSD4
	IF FSDNAM[A] = T[1] GOTO SWIFSD2
	LET A =+ 2
	GOTO SWIFSD1
SWIFSD2:
	INC A
	IF FSDNAM[A] = T[2] GOTO SWIFSD3
	INC A
	GOTO SWIFSD1
SWIFSD3:
	LET CURFSD[1] = FSDPIP[A]
	DEC A
	LET CURFSD[0] = FSDPIP[A]
	RETURN
SWIFSD4:
	LET C = 22
	RETURN
	
SWISUB:
	IF T[3] = 255 GOTO SWISUB2
	IF T[3] > 7 GOTO SWISUB1
	RETURN
SWISUB1:
	IF T[3] = 254 GOTO RET
	LET C = 19
	RETURN
SWISUB2:
	LET T[3] = CURSUB
	RETURN

PCBCLI:
	LET T[0] = 0
	LET T[127] = 0
	GOTO CLION
KILLPROC:
	LET T[0] = 0
	KILL T[1]
	IF T[127] = 255 GOSUB CLION
	DALLOC T
	LET PCBSTAT[G] = 0
	RETURN
	
TEMTOCUR:
	LET CURFSD = TEMFSD
	LET CURSUB = TEMSUB
	RETURN
	
CURTOTEM:
	LET TEMFSD = CURFSD
	LET TEMSUB = CURSUB
	RETURN
	
ERRORSWI:
	GOSUB TEMTOCUR
ERRORPCB:
	LET O = #SIO
	LET T[126] = C
	LET T[0] = 0
	RETURN
	
HANCLI:
	IF ISBAT = 0 GOSUB GETC
	IF ISBAT = 1 GOSUB READBAT
	IF C = 0 GOTO RET
	IF C = 8 GOTO CLIBACK
	IF CLIP = 251 GOTO RET
	IF C = 10 GOTO CLIEXEC
	IF C < 32 GOTO RET
	IF C > 95 GOTO RET
	LET CLIBUF[CLIP] = C
	INC CLIP
	IF CLIPRINT = 1 GOSUB PUTC
	RETURN
	
CLIBACK:
	IF CLIP = 0 GOTO RET
	DEC CLIP
	GOSUB PUTC
	RETURN
	
CLIEXEC:
	LET CLIBUF[CLIP] = 0
	IF CLIPRINT = 1 GOSUB NEWLINE
CLILOAD:
	LET F = 0
	LET CLIP = 0
	IF CLIBUF[CLIP] = 47 GOTO CLICOM
	LET AE[0] = 1
	LET AE[1] = CURSUB
	LET AE[2] = 0
	LET AE[3] = 0
	LET I = 4
CLIEXEC1:
	LET AE[I] = CLIBUF[CLIP]
	INC CLIP
	INC I
	IF CLIBUF[CLIP] < 33 GOTO CLIEXEC2
	IF CLIP < 8 GOTO CLIEXEC1
	LET E = 21
	LET C = 21
	IF ISPCB = 1 GOTO RET
	GOSUB ERROR
	GOTO CLION
CLIEXEC2:
	LET AE[I] = PRG[F]
	INC F
	INC I
	IF F < 5 GOTO CLIEXEC2
	LET B = 2
CLIEXEC3:
	GOSUB GETSEC
	IF C > 0 GOTO ERRORCLI
	LET I = 128
CLIEXEC4:
	GOSUB PULLC
	DEC I
	IF B = 3 GOSUB CLIEXEC7
	IF B = 2 GOSUB CLIEXEC5
	IF I > 0 GOTO CLIEXEC4
	LET AE[2] =+ 1
	IF B > 1 GOTO CLIEXEC3
	LET O = #SIO
	IF B = 1 GOTO CLIEXEC8
	LET E = D
	IF ISPCB = 0 GOTO ERROR
	RETURN
CLIEXEC5:
	INITPRG C,E
	IF E > 0 GOTO CLIEXEC6
	ALLOC T,1,E
	IF E > 0 GOTO CLIEXEC6
	LET T[128] = 0
	GOSUB WRITEARG
	LET T[127] = 0
	LET T[0] = 0
	IF ISCLI = 1 GOSUB CLIEXEC9
	LOADPRG #SIO,T
	INC B
	RETURN
CLIEXEC6:
	LET D = E
	LET B = 0
	RETURN
CLIEXEC7:
	WRITEPRG C,E
	IF E = 255 GOTO RET
	LET NEWPID = E
	LET B = 1
	RETURN
CLIEXEC8:
	IF ISCLI = 1 GOSUB CLIOFF
	LET I = 0
NEWPCB1:
	LET A = PCBSTAT[I]
	IF A = 0 GOTO NEWPCB2
	INC I
	LET E = 7
	IF I = MAXPRG GOTO PANIC
	GOTO NEWPCB1
NEWPCB2:
	LET PCBSTAT[I] = 1
	GOSUB GETPCB
	LET O = #SIO
	LET E = 0
	RETURN
CLIEXEC9:
	LET T[127] = 255
	RETURN
WRITEARG:
	LET G = 128
	IF CLIBUF[CLIP] = 32 GOTO WRITEARG1
	RETURN
WRITEARG1:
	INC CLIP
	LET T[G] = CLIBUF[CLIP]
	IF CLIBUF[CLIP] = 0 GOTO RET
	INC G
	IF G = 0 GOTO RET
	GOTO WRITEARG1
	
CLICOM:
	IF CLIBUF[1] = 67 GOSUB CHFSD
	GOTO CLION
	
CHFSD:
	IF CLIBUF[2] = 0 GOTO RET
	IF CLIBUF[3] < 48 GOTO RET
	IF CLIBUF[3] > 56 GOTO RET
	LET CLIBUF[3] =- 48
	LET CURSUB = CLIBUF[3]
	RETURN
	
CLION:
	LET ISCLI = 1
	LET CLIP = 0
	LET I = 4
	IF CLIPON = 1 GOSUB PRINTON
	IF CLIPRINT = 1 GOSUB PRINTI
	RETURN
	
PRINTON:
	LET CLIPON = 0
	LET CLIPRINT = 1
	RETURN
	
CLIOFF:
	LET ISCLI = 0
	RETURN

BATEXE:
	ALLOC BUF,1,E
	IF E > 0 GOTO ERROR
	LET ISBAT = 1
	LET CLIPRINT = 0

BATLOAD:
	LET V = 0
BATLOAD1:
	LET AE[V] = BE[V]
	INC V
	IF V < 20 GOTO BATLOAD1
	GOSUB GETSEC
	IF C > 0 GOTO BATFIN
	LET V = 0
BATLOAD2:
	GOSUB PULLC
	LET BUF[V] = C
	INC V
	IF V < 128 GOTO BATLOAD2
	LET V = 0
	LET O = #SIO
	RETURN
	
READBAT:
	IF V = 128 GOSUB NEXTBAT
	IF BUF[V] = 0 GOTO BATFIN
	LET C = BUF[V]
	INC V
	RETURN
	
NEXTBAT:
	LET BE[2] =+ 1
	IF BE[2] = 0 GOTO NEXTBAT1
	LET BE[3] =+ 1
NEXTBAT1:
	IF BE[3] = 0 GOTO BATFIN
	GOTO BATLOAD

BATFIN:
	DALLOC BUF
	LET ISBAT = 0
	LET CLIPON = 1
	LET C = 10
	RETURN

GETSEC:
	LET O = CURFSD
	LET A = 0
GETSEC1:
	LET C = AE[A]
	GOSUB PUTC
	INC A
	IF A < 5 GOTO GETSEC1
GETSEC2:
	LET C = AE[A]
	GOSUB PUTC
	INC A
	IF AE[A] > 0 GOTO GETSEC2 
	LET C = 0
	GOSUB PUTC
	GOSUB PULLC
	RETURN
	
ERRORCLI:
	LET E = C
	IF ISPCB = 1 GOTO RET
	GOSUB ERRORC
	GOTO CLION
ERRORC:
	LET E = C
ERROR:
	LET F = E
	LET I = 3
	LET O = #SIO
	GOSUB PRINTI
	LET C = F
	GOSUB PRINTB
	GOTO NEWLINE
	
CHECKE:
	IF E > 0 GOTO PANIC
	RETURN
PANICC:
	LET E = C
PANIC:
	LET F = E
	LET I = 1
	GOSUB PRINTI
	LET C = F
	GOSUB PRINTB
HALT:
	GOTO HALT
	
	;GETPCB: SWAPS T AND THE PCB SELECTED BY I
	;PRINTB: PRINTS A BYTE IN ASCII
	;PRINTH: PRINTS A HEX IN ASCII
	;PRINTI: PRINTS SECTION I FROM STRING S
	;PRINTS: PRINTS CHAR A FROM STRING S
	;PUTC:   PRINTS BYTE C
	;GETC:   READS BYTE C
	;PULLC:  WAITS TO READ BYTE C
	
GETPCB:
	IF I = 0 GOTO GETPCB0
	IF I = 1 GOTO GETPCB1
	IF I = 2 GOTO GETPCB2
	IF I = 3 GOTO GETPCB3
	IF I = 4 GOTO GETPCB4
	IF I = 5 GOTO GETPCB5
	IF I = 6 GOTO GETPCB6
	IF I = 7 GOTO GETPCB7
	IF I = 8 GOTO GETPCB8
	IF I = 9 GOTO GETPCB9
	IF I = 10 GOTO GETPCB10
	IF I = 11 GOTO GETPCB11
	IF I = 12 GOTO GETPCB12
	IF I = 13 GOTO GETPCB13
	IF I = 14 GOTO GETPCB14
	IF I = 15 GOTO GETPCB15
	RETURN
	
GETPCB0:
	MOVE R,P0
	MOVE P0,T
	MOVE T,R
	RETURN
GETPCB1:
	MOVE R,P1
	MOVE P1,T
	MOVE T,R
	RETURN
GETPCB2:
	MOVE R,P2
	MOVE P2,T
	MOVE T,R
	RETURN
GETPCB3:
	MOVE R,P3
	MOVE P3,T
	MOVE T,R
	RETURN
GETPCB4:
	MOVE R,P4
	MOVE P4,T
	MOVE T,R
	RETURN
GETPCB5:
	MOVE R,P5
	MOVE P5,T
	MOVE T,R
	RETURN
GETPCB6:
	MOVE R,P6
	MOVE P6,T
	MOVE T,R
	RETURN
GETPCB7:
	MOVE R,P7
	MOVE P7,T
	MOVE T,R
	RETURN
GETPCB8:
	MOVE R,P8
	MOVE P8,T
	MOVE T,R
	RETURN
GETPCB9:
	MOVE R,P9
	MOVE P9,T
	MOVE T,R
	RETURN
GETPCB10:
	MOVE R,P10
	MOVE P10,T
	MOVE T,R
	RETURN
GETPCB11:
	MOVE R,P11
	MOVE P11,T
	MOVE T,R
	RETURN
GETPCB12:
	MOVE R,P12
	MOVE P12,T
	MOVE T,R
	RETURN
GETPCB13:
	MOVE R,P13
	MOVE P13,T
	MOVE T,R
	RETURN
GETPCB14:
	MOVE R,P14
	MOVE P14,T
	MOVE T,R
	RETURN
GETPCB15:
	MOVE R,P15
	MOVE P15,T
	MOVE T,R
	RETURN


NEWLINE:
	LET C = 10
	GOTO PUTC
PRINTB:
	SPLIT C,B,A
	LET C = A
	GOSUB PRINTH
	LET C = B
	GOTO PRINTH
PRINTH:
	LET C =+ 48
	IF C > 57 GOSUB PRINTH1
	GOSUB PUTC
	RETURN
PRINTH1:
	LET C =+ 7
	RETURN
PRINTI:
	LET A = 0
PRINTI1:
	IF I = 0 GOTO PRINTS
PRINTI2:
	IF S[A] = 0 GOTO DECI
	INC A
	GOTO PRINTI2
DECI:
	INC A
	DEC I
	GOTO PRINTI1
PRINTS:
	LET C = S[A]
	GOSUB PUTC
	IF S[A] = 0 GOTO RET
	INC A
	GOTO PRINTS
RET:
	RETURN
PUTC:
	WRITE O,C,E
	IF E > 0 GOTO PERR
	RETURN
PERR:
	FORFIT
	GOTO PUTC
GETC:
	READ O,C,E
	IF E > 0 GOTO GERR
	RETURN
GERR:
	LET C = 0
	RETURN
PULLC:
	READ O,C,E
	IF E > 0 GOTO PUERR
	RETURN
PUERR:
	FORFIT
	GOTO PULLC